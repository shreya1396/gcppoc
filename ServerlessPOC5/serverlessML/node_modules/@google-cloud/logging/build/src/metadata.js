"use strict";
/*!
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const gcpMetadata = require("gcp-metadata");
const pify = require("pify");
const readFile = pify(fs.readFile);
function zoneFromQualifiedZone(qualified) {
    // Some parsing is necessary. Metadata service returns a fully
    // qualified zone name: 'projects/{projectId}/zones/{zone}'. Logging
    // wants just the zone part.
    //
    return qualified.split('/').pop();
}
/**
 * Create a descriptor for Cloud Functions.
 *
 * @returns {object}
 */
function getCloudFunctionDescriptor() {
    return {
        type: 'cloud_function',
        labels: {
            function_name: process.env.FUNCTION_NAME,
            region: process.env.FUNCTION_REGION,
        },
    };
}
exports.getCloudFunctionDescriptor = getCloudFunctionDescriptor;
/**
 * Create a descriptor for Google App Engine.
 *
 * @returns {object}
 */
function getGAEDescriptor() {
    return __awaiter(this, void 0, void 0, function* () {
        const qualifiedZone = yield gcpMetadata.instance('zone');
        const zone = zoneFromQualifiedZone(qualifiedZone);
        return {
            type: 'gae_app',
            labels: {
                module_id: process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME,
                version_id: process.env.GAE_VERSION,
                zone
            },
        };
    });
}
exports.getGAEDescriptor = getGAEDescriptor;
/**
 * Create a descriptor for Google Compute Engine.
 * @return {object}
 */
function getGCEDescriptor() {
    return __awaiter(this, void 0, void 0, function* () {
        const idResponse = yield gcpMetadata.instance('id');
        const zoneResponse = yield gcpMetadata.instance('zone');
        // Some parsing is necessary. Metadata service returns a fully
        // qualified zone name: 'projects/{projectId}/zones/{zone}'. Logging
        // wants just the zone part.
        //
        const zone = zoneFromQualifiedZone(zoneResponse);
        return {
            type: 'gce_instance',
            labels: {
                // idResponse can be BigNumber when the id too large for JavaScript
                // numbers. Use a toString() to uniformly convert to a string.
                instance_id: idResponse.toString(),
                zone,
            },
        };
    });
}
exports.getGCEDescriptor = getGCEDescriptor;
exports.KUBERNETES_NAMESPACE_ID_PATH = '/var/run/secrets/kubernetes.io/serviceaccount/namespace';
/**
 * Create a descriptor for Google Container Engine.
 *
 * @return {object}
 */
function getGKEDescriptor() {
    return __awaiter(this, void 0, void 0, function* () {
        // Stackdriver Logging Monitored Resource for 'container' requires
        // cluster_name and namespace_id fields. Note that these *need* to be
        // snake_case. The namespace_id is not easily available from inside the
        // container, but we can get the namespace_name. Logging has been using the
        // namespace_name in place of namespace_id for a while now. Log correlation
        // with metrics may not necessarily work however.
        //
        const resp = yield gcpMetadata.instance('attributes/cluster-name');
        let namespace;
        try {
            namespace = yield readFile(exports.KUBERNETES_NAMESPACE_ID_PATH, 'utf8');
        }
        catch (err) {
            throw new Error(`Error reading ${exports.KUBERNETES_NAMESPACE_ID_PATH}: ${err.message}`);
        }
        return {
            type: 'container',
            labels: {
                cluster_name: resp,
                namespace_id: namespace,
            },
        };
    });
}
exports.getGKEDescriptor = getGKEDescriptor;
/**
 * Create a global descriptor.
 *
 * @returns {object}
 */
function getGlobalDescriptor() {
    return {
        type: 'global',
    };
}
exports.getGlobalDescriptor = getGlobalDescriptor;
/**
 * Attempt to contact the metadata service and determine,
 * based on request success and environment variables, what type of resource
 * the library is operating on.
 */
function getDefaultResource(auth) {
    return __awaiter(this, void 0, void 0, function* () {
        const env = yield auth.getEnv();
        switch (env) {
            case 'KUBERNETES_ENGINE':
                return getGKEDescriptor();
            case 'APP_ENGINE':
                return getGAEDescriptor();
            case 'CLOUD_FUNCTIONS':
                return getCloudFunctionDescriptor();
            case 'COMPUTE_ENGINE':
                // Test for compute engine should be done after all the rest -
                // everything runs on top of compute engine.
                return getGCEDescriptor();
            default:
                return getGlobalDescriptor();
        }
    });
}
exports.getDefaultResource = getDefaultResource;
//# sourceMappingURL=metadata.js.map