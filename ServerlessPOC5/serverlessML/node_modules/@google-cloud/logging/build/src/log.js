"use strict";
/*!
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const promisify_1 = require("@google-cloud/promisify");
const arrify = require("arrify");
const extend = require("extend");
const is = require("is");
const entry_1 = require("./entry");
const metadata_1 = require("./metadata");
const snakeCaseKeys = require('snakecase-keys');
/**
 * A log is a named collection of entries, each entry representing a timestamped
 * event. Logs can be produced by Google Cloud Platform services, by third-party
 * services, or by your applications. For example, the log `apache-access` is
 * produced by the Apache Web Server, but the log
 * `compute.googleapis.com/activity_log` is produced by Google Compute Engine.
 *
 * @see [Introduction to Logs]{@link https://cloud.google.com/logging/docs/basic-concepts#logs}
 *
 * @class
 *
 * @param {Logging} logging {@link Logging} instance.
 * @param {string} name Name of the log.
 * @param {object} [options] Configuration object.
 * @param {boolean} [options.removeCircular] Replace circular references in
 *     logged objects with a string value, `[Circular]`. (Default: false)
 *
 * @example
 * const {Logging} = require('@google-cloud/logging');
 * const logging = new Logging();
 * const log = logging.log('syslog');
 */
class Log {
    constructor(logging, name, options) {
        options = options || {};
        this.formattedName_ = Log.formatName_(logging.projectId, name);
        this.removeCircular_ = options.removeCircular === true;
        this.logging = logging;
        /**
         * @name Log#name
         * @type {string}
         */
        this.name = this.formattedName_.split('/').pop();
    }
    alert(entry, optionsOrCallback, cb) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        this.write(Log.assignSeverityToEntries_(entry, 'ALERT'), options, callback);
    }
    critical(entry, optionsOrCallback, cb) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        const entries = Log.assignSeverityToEntries_(entry, 'CRITICAL');
        this.write(entries, options, callback);
    }
    debug(entry, optionsOrCallback, cb) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        this.write(Log.assignSeverityToEntries_(entry, 'DEBUG'), options, callback);
    }
    delete(optionsOrCallback, cb) {
        const gaxOptions = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        const reqOpts = {
            logName: this.formattedName_,
        };
        this.logging.request({
            client: 'LoggingServiceV2Client',
            method: 'deleteLog',
            reqOpts,
            gaxOpts: gaxOptions,
        }, callback);
    }
    emergency(entry, optionsOrCallback, cb) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        const entries = Log.assignSeverityToEntries_(entry, 'EMERGENCY');
        this.write(entries, options, callback);
    }
    /**
     * Create an entry object for this log.
     *
     * Note that using this method will not itself make any API requests. You will
     * use the object returned in other API calls, such as
     * {@link Log#write}.
     *
     * @see [LogEntry JSON representation]{@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry}
     *
     * @param {?object} metadata See a
     *     [LogEntry
     * Resource](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry).
     * @param {object|string} data The data to use as the value for this log
     *     entry.
     * @returns {Entry}
     *
     * @example
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     * const log = logging.log('my-log');
     *
     * const metadata = {
     *   resource: {
     *     type: 'gce_instance',
     *     labels: {
     *       zone: 'global',
     *       instance_id: '3'
     *     }
     *   }
     * };
     *
     * const entry = log.entry(metadata, {
     *   delegate: 'my_username'
     * });
     *
     * entry.toJSON();
     * // {
     * //   logName: 'projects/grape-spaceship-123/logs/syslog',
     * //   resource: {
     * //     type: 'gce_instance',
     * //     labels: {
     * //       zone: 'global',
     * //       instance_id: '3'
     * //     }
     * //   },
     * //   jsonPayload: {
     * //     delegate: 'my_username'
     * //   }
     * // }
     */
    entry(metadata, data) {
        if (!data) {
            data = metadata;
            metadata = {};
        }
        return this.logging.entry(metadata, data);
    }
    error(entry, optionsOrCallback, cb) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        this.write(Log.assignSeverityToEntries_(entry, 'ERROR'), options, callback);
    }
    /**
     * This method is a wrapper around {module:logging#getEntries}, but with a
     * filter specified to only return entries from this log.
     *
     * @see [entries.list API Documentation]{@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/entries/list}
     *
     * @param {GetEntriesRequest} [query] Query object for listing entries.
     * @param {GetEntriesCallback} [callback] Callback function.
     * @returns {Promise<GetEntriesResponse>}
     *
     * @example
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     * const log = logging.log('my-log');
     *
     * log.getEntries((err, entries) => {
     *   // `entries` is an array of Stackdriver Logging entry objects.
     *   // See the `data` property to read the data from the entry.
     * });
     *
     * //-
     * // To control how many API requests are made and page through the results
     * // manually, set `autoPaginate` to `false`.
     * //-
     * function callback(err, entries, nextQuery, apiResponse) {
     *   if (nextQuery) {
     *     // More results exist.
     *     log.getEntries(nextQuery, callback);
     *   }
     * }
     *
     * log.getEntries({
     *   autoPaginate: false
     * }, callback);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * log.getEntries().then(data => {
     *   const entries = data[0];
     * });
     */
    getEntries(options, callback) {
        if (is.function(options)) {
            callback = options;
            options = {};
        }
        options = extend({
            filter: 'logName="' + this.formattedName_ + '"',
        }, options);
        return this.logging.getEntries(options, callback);
    }
    /**
     * This method is a wrapper around {module:logging#getEntriesStream}, but with a
     * filter specified to only return {module:logging/entry} objects from this log.
     *
     * @method Log#getEntriesStream
     * @param {GetEntriesRequest} [query] Query object for listing entries.
     * @returns {ReadableStream} A readable stream that emits {@link Entry}
     *     instances.
     *
     * @example
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     * const log = logging.log('my-log');
     *
     * log.getEntriesStream()
     *   .on('error', console.error)
     *   .on('data', entry => {
     *     // `entry` is a Stackdriver Logging entry object.
     *     // See the `data` property to read the data from the entry.
     *   })
     *   .on('end', function() {
     *     // All entries retrieved.
     *   });
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * log.getEntriesStream()
     *   .on('data', function(entry) {
     *     this.end();
     *   });
     */
    getEntriesStream(options) {
        options = extend({
            filter: 'logName="' + this.formattedName_ + '"',
        }, options);
        return this.logging.getEntriesStream(options);
    }
    info(entry, optionsOrCallback, cb) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        this.write(Log.assignSeverityToEntries_(entry, 'INFO'), options, callback);
    }
    notice(entry, optionsOrCallback, cb) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        this.write(Log.assignSeverityToEntries_(entry, 'NOTICE'), options, callback);
    }
    warning(entry, optionsOrCallback, cb) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        this.write(Log.assignSeverityToEntries_(entry, 'WARNING'), options, callback);
    }
    write(entry, optionsOrCallback, cb) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        const self = this;
        if (options.resource) {
            if (options.resource.labels) {
                options.resource.labels = snakeCaseKeys(options.resource.labels);
            }
            writeWithResource(options.resource);
        }
        else if (this.logging.detectedResource) {
            writeWithResource(this.logging.detectedResource);
        }
        else {
            metadata_1.getDefaultResource(this.logging.auth)
                .then((resource) => {
                this.logging.detectedResource = resource;
                writeWithResource(resource);
            }, () => {
                // Ignore errors (the API will speak up if it has an issue).
                writeWithResource(null);
            });
        }
        function writeWithResource(resource) {
            let decoratedEntries;
            try {
                decoratedEntries = self.decorateEntries_(arrify(entry));
            }
            catch (err) {
                // Ignore errors (the API will speak up if it has an issue).
            }
            const reqOpts = extend({
                logName: self.formattedName_,
                entries: decoratedEntries,
                resource,
            }, options);
            delete reqOpts.gaxOptions;
            self.logging.request({
                client: 'LoggingServiceV2Client',
                method: 'writeLogEntries',
                reqOpts,
                gaxOpts: options.gaxOptions,
            }, callback);
        }
    }
    /**
     * All entries are passed through here in order to get them serialized.
     *
     * @private
     *
     * @param {object[]} entries - Entry objects.
     * @returns {object[]} Serialized entries.
     * @throws if there is an error during serialization.
     */
    decorateEntries_(entries) {
        return entries.map(entry => {
            if (!(entry instanceof entry_1.Entry)) {
                entry = this.entry(entry);
            }
            return entry.toJSON({
                removeCircular: this.removeCircular_,
            });
        });
    }
    /**
     * Return an array of log entries with the desired severity assigned.
     *
     * @private
     *
     * @param {object|object[]} entries - Log entries.
     * @param {string} severity - The desired severity level.
     */
    static assignSeverityToEntries_(entries, severity) {
        return arrify(entries).map(entry => {
            const metadata = extend(true, {}, entry.metadata, {
                severity,
            });
            return extend(new entry_1.Entry(), entry, {
                metadata,
            });
        });
    }
    /**
     * Format the name of a log. A log's full name is in the format of
     * 'projects/{projectId}/logs/{logName}'.
     *
     * @private
     *
     * @returns {string}
     */
    static formatName_(projectId, name) {
        const path = 'projects/' + projectId + '/logs/';
        name = name.replace(path, '');
        if (decodeURIComponent(name) === name) {
            // The name has not been encoded yet.
            name = encodeURIComponent(name);
        }
        return path + name;
    }
}
exports.Log = Log;
/*! Developer Documentation
 *
 * All async methods (except for streams) will return a Promise in the event
 * that a callback is omitted.
 */
promisify_1.promisifyAll(Log, {
    exclude: ['entry'],
});
//# sourceMappingURL=log.js.map